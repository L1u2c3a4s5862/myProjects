#!/usr/local/bin/python3
# -*- coding: utf-8 -*-

from sympy import randprime
from math import gcd
import argparse

# generating banners
banner = """
 ██▀███    ██████  ▄▄▄          ▄████▄   ██▓ ██▓███   ██░ ██ ▓█████  ██▀███  
▓██ ▒ ██▒▒██    ▒ ▒████▄       ▒██▀ ▀█  ▓██▒▓██░  ██▒▓██░ ██▒▓█   ▀ ▓██ ▒ ██▒
▓██ ░▄█ ▒░ ▓██▄   ▒██  ▀█▄     ▒▓█    ▄ ▒██▒▓██░ ██▓▒▒██▀▀██░▒███   ▓██ ░▄█ ▒
▒██▀▀█▄    ▒   ██▒░██▄▄▄▄██    ▒▓▓▄ ▄██▒░██░▒██▄█▓▒ ▒░▓█ ░██ ▒▓█  ▄ ▒██▀▀█▄  
░██▓ ▒██▒▒██████▒▒ ▓█   ▓██▒   ▒ ▓███▀ ░░██░▒██▒ ░  ░░▓█▒░██▓░▒████▒░██▓ ▒██▒
░ ▒▓ ░▒▓░▒ ▒▓▒ ▒ ░ ▒▒   ▓▒█░   ░ ░▒ ▒  ░░▓  ▒▓▒░ ░  ░ ▒ ░░▒░▒░░ ▒░ ░░ ▒▓ ░▒▓░
\033[1;35m                            -=Author: Lucas Liu=-                            \033[1;0m
"""
def banners(banner):
    print(banner)

#! main function
def rsaCipher(message):
    # p and q
    p = randprime(200, 300)
    q = randprime(400, 500)
    # find e
    def find_e(phi):
        e = 2
        while gcd(phi, e) != 1:
            e += 1
        return e
    # find d
    def find_d(e, phi):
        for i in range(1, phi):
            if (i * e) % phi == 1:
                return i
        return None
    # rsa key generation
    def rsa_key_generation(p, q):
        n = p * q
        phi = (p - 1) * (q - 1)
        e = find_e(phi)
        d = find_d(e, phi)
        return ((e, n), (d, n))
    # public key and private key
    public_key, private_key = rsa_key_generation(p, q)
    # rsa encryption
    e, n = public_key
    encrypted_message = [pow(ord(char), e, n) for char in message]
    print(f"p={p}, q={q}")
    print(f"public key: \033[1;35m{public_key}\033[1;0m\nprivate key: \033[1;35m{private_key}\033[1;0m")
    print(f"Encrypted message: \033[1;34m{encrypted_message}\033[1;0m")

# creating argument
if __name__ == "__main__":
    parser = argparse.ArgumentParser(formatter_class=argparse.RawTextHelpFormatter, description=banners(banner))
    parser.add_argument("message", help="message to be encrypted or decrypted")
    args = parser.parse_args()

    rsaCipher(args.message)
